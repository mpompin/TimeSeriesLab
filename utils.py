'''
helper functions
'''
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import acf, pacf
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.stats.diagnostic import acorr_ljungbox
import nolitsa

def read_datfile(path):
    xV = np.loadtxt(path)
    return xV

def rolling_window(xV, window):
    return np.convolve(xV, np.ones(window), mode='valid') / window

def polynomial_fit(xV, p):
    '''
    fit to a given time series with a polynomial of a given order.
    :param xV: vector of length 'n' of the time series
    :param p: the order of the polynomial to be fitted
    :return: vector of length 'n' of the fitted time series
    '''
    n = xV.shape[0]
    xV = xV[:]
    if p > 1:
        tV = np.arange(n)
        bV = np.polyfit(x=tV, y=xV, deg=p)
        muV = np.polyval(p=bV, x=tV)
    else:
        muV = np.full(shape=n, fill_value=np.nan)
    return muV


def embed_data(x, m, tau):
    pass


def generate_arma_ts(phiV, thetaV, n, sdnoise=1):
    '''
    Generate an ARMA(p,q) time series of length 'n' with Gaussian input noise.
    Note that phiV = [phi(0) phi(1) ... phi(p)]' and phi(0) is the constant
    term, and thetaV = [theta(1) ... theta(q)]'.
    sdnoise is the SD of the input noise (if left out then sdnoise=1).
    The generating ARMA(p,q) process reads
    x(t) = phi(0) + phi(1)*x(t-1) + ... + phi(p)*x(t-p) +
            +z(t) - theta(1)*z(t-1) + ... - theta(q)*z(t-p),
    z(t) ~ WN(0,sdnoise^2)
    '''
    from statsmodels.tsa.arima_process import arma_generate_sample
    ar_params = np.r_[1, -phiV[:]]  # add zero lag
    ma_params = np.r_[1, thetaV[:]]  # add zero lag
    xV = arma_generate_sample(ar=ar_params, ma=ma_params, nsample=n, scale=sdnoise, burnin=100)
    return xV
    # q = len(thetaV)
    # p = len(phiV) - 1
    # pq = np.max(p, q)
    # ntrans = 100 + pq
    # phiV = phiV[:]
    # thetaV = thetaV[:]
    # if p > 0:
    #     root_arV = np.roots(np.r_[1, -phiV[1:]])
    #     if np.any(np.abs(root_arV) >= 1):
    #         print(f'The AR({p}) part of the process is not stationary.\n')
    # if q > 0:
    #     root_maV = np.roots(np.r_[1, -thetaV[1:]])
    #     if np.any(np.abs(root_maV) >= 1):
    #         print(f'The MA({p}) part of the process is not stationary.\n')
    # x0V = sdnoise * np.random.normal(size=(pq, 1))
    # zV = sdnoise * np.random.normal(size=(n+ntrans, 1))
    # xV = np.full(shape=(n+ntrans, 1), fill_value=np.nan)
    # xV[:pq] = x0V
    # if p == 0:
    #     for i in np.arange(pq+1, n+ntrans):
    #         xV[i] = phiV[0] + zV[i] - thetaV * np.flipud(zV[i - q:i])
    # elif q == 0:
    #     for i in np.arange(pq+1, n+ntrans):
    #         xV[i] = phiV[0] + phiV[1: p+1] * np.flipud(xV[i-p:i-1]) + zV[i]
    # else:
    #     for i in np.arange(pq+1, n+ntrans):
    #         xV[i] = phiV[0] + phiV[1:p+1] * np.flipud(xV[i-p:i-1]) + zV[i] - thetaV * np.flipud(zV[i-q:i-1])
    # xV = xV[ntrans + 1:]
    # return xV

def add_stochastic_trend(xV):
    '''
    adds a stochastic trend to a given time series (for
    simulating purposes). The time series of stochastic trend is generated by
    simulating a smoothed random walk time series of the same length as that of the
    given time series.
    :param xV: vector of length 'n' of the given time series
    :return: vector of length 'n' of the sum of the given time series and a stochastic trend.
    '''
    xV = xV[:]
    n = xV.shape[0]
    maorder = np.round(n // 5)
    x_std = np.std(xV)
    zV = 0.1 * x_std * np.random.normal(n)
    zV = np.cumsum(zV)
    wV = rolling_window(zV, window=maorder)
    yV = xV + wV
    return yV